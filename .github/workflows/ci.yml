#* GitHub Actions workflow to validate and process pull requests
name: CI

#? Triggers when PR is edited, opened, reopened, or synchronized (new commits)
on:
  pull_request:
    types:
      - edited
      - opened
      - reopened
      - synchronize

#* Environment variables available to all jobs
env:
  CI: true #? Indicates this is running in CI environment
  GEMINI_TOKEN: ${{ secrets.GEMINI_API_KEY }} #? API key for Gemini service (stored as repository secret)
  GITHUB_REPOSITORY: ${{ github.repository }} #? Repository name in owner/repo format
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} #? GitHub token for repository operations
  HEAD_REF: ${{ github.event.pull_request.head.ref }} #? Source branch name of the PR
  NODE_ENV: production #? Sets Node.js environment to production mode
  NODE_OPTIONS: --max-old-space-size=4096 #? Increases Node.js memory limit to 4GB
  NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }} #? NPM authentication token for publishing
  PR_NUMBER: ${{ github.event.pull_request.number }} #? Pull request number for reference

jobs:
  ci:

    #* Main validation job that performs all checks and builds
    name: Pipeline
    runs-on: ubuntu-latest #? Uses the latest Ubuntu runner environment

    permissions:
      contents: write #? Allows pushing commits back to the repository
      packages: write #? Enables publishing packages if needed

    steps:
      #* Step 1: Checkout the repository code
      - name: Consume
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 #? Fetches complete history for proper git operations
          ref: ${{ github.event.pull_request.head.sha }} #? Checks out specific PR head commit

      #* Step 2: Setup Node.js environment
      - name: Prepare
        uses: actions/setup-node@v4
        with:
          node-version: 22.x #? Uses Node.js version 22.x
          registry-url: https://registry.npmjs.org #? Configures npm registry
          cache: npm #? Caches npm dependencies for faster builds

      #* Step 3: Install project dependencies
      - name: Install
        run: npm ci #? Clean install dependencies from package-lock.json

      #* Step 4: Run code formatting and linting checks
      - name: Analyze
        run: npm run format:check #? Validates code formatting with Prettier

      #* Step 5: Configure git for automated commits
      - name: Configure
        run: |
          #? Set up git identity for automated commits
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          #? Configure remote URL with authentication token
          git remote set-url origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}"
          #* The checkout action checks out the PR head SHA. We need to be on the branch for commits.
          git fetch origin "$HEAD_REF"
          git checkout "$HEAD_REF"

      #* Step 6: Build project and commit changes in stages
      - name: Check-in
        id: build_and_commit
        env:
          BRANCH_REF: $HEAD_REF
        run: |
          echo "Running build process (lint fixes, test coverage, dist generation)…"

          #* Assumes 'npm run build' executes prebuild (lint fixes, test coverage) and then builds dist.
          npm run build
          ANY_COMMITS_MADE=false #? Track if any commits were made during this step

          #* Define helper function for git reset operations
          git_reset() {
            if [ "$1" = "clear" ]; then
              git reset > /dev/null 2>&1 #? Clear staging area
            elif [ "$1" = "unstage" ] && [ -d "$2" ] && git diff --name-only --staged -- "$2" | grep -q .; then
              echo "Unstaging $2/ for lint commit."
              git reset HEAD -- "$2" #? Unstage specific directory
            fi
          }

          #* Commit 1: Lint/Format changes (non-dist, non-coverage files)
          echo "Checking for lint/format changes…"
          git_reset clear #? Clear any prior staging
          git add -A #? Stage all changes initially

          #* Unstage dist and coverage if they exist and have staged changes
          git_reset unstage "dist"
          git_reset unstage "docs/tests"
          if ! git diff --staged --quiet; then #? Check if there are staged changes
            echo "Committing lint/format changes…"
            git commit -m "fix: aligns syntax to lint and format standards"
            ANY_COMMITS_MADE=true
          else
            echo "No lint/format changes to commit."
          fi

          #* Commit 2: Test coverage results
          echo "Checking for test coverage changes…"
          git reset > /dev/null 2>&1 #? Clear any prior staging
          if [ -d "coverage" ]; then
            git add coverage/
            if ! git diff --staged --quiet; then #? Check if adding coverage dir staged anything
              echo "Committing test coverage results…"
              git commit -m "chore: updates test coverage results"
              ANY_COMMITS_MADE=true
            else
              echo "No new or modified test coverage results to commit."
            fi
          else
            echo "Coverage directory not found, skipping coverage commit."
          fi

          #* Commit 3: Distributable files
          echo "Checking for dist directory changes…"
          git reset > /dev/null 2>&1 #? Clear any prior staging
          if [ -d "dist" ]; then
            git add dist/
            if ! git diff --staged --quiet; then #? Check if adding dist dir staged anything
              echo "Committing dist files…"
              git commit -m "dist: updates type, source-map, and library files"
              ANY_COMMITS_MADE=true
            else
              echo "No new or modified dist files to commit."
            fi
          else
            echo "Dist directory not found, skipping dist commit."
          fi

          #? Push all commits if any were made
          if [ "$ANY_COMMITS_MADE" = true ]; then
            git push origin "$BRANCH_REF"
          else
            echo "No changes were committed by this step."
          fi
          echo "any_commits_made=$ANY_COMMITS_MADE" >> $GITHUB_OUTPUT #? Output for subsequent steps

      #* Step 7: Version package and create distribution archives
      - name: Package
        id: version_publish_compress
        run: |
          #! Early exit if required directories/files are missing
          if [ ! -d "dist" ] || [ ! -f "package.json" ]; then
            echo "Dist directory or package.json not found. Skipping versioning, publishing, and compression."
            echo "skipped_all=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "skipped_all=false" >> $GITHUB_OUTPUT

          #? Determine version bump type based on branch naming convention
          echo "Determining version bump type from branch: $HEAD_REF…"
          BRANCH_NAME="$HEAD_REF"
          VERSION_BUMP="minor" #? Default version bump
          if [[ "$BRANCH_NAME" == fix/* ]]; then
            VERSION_BUMP="patch" #? Bug fixes get patch version
          elif [[ "$BRANCH_NAME" == refac/* ]]; then
            VERSION_BUMP="major" #? Refactoring gets major version
          fi
          echo "Determined version bump: $VERSION_BUMP"

          #* Update package version and create git tag
          echo "Updating package version, creating tag, and preparing for publish via postversion script…"

          #* Assumes package.json contains: "postversion" script to handle versioning tasks.
          npm version $VERSION_BUMP -m "chore(release): version %s for PR #$PR_NUMBER"

          #? Push version commit and tags to remote
          echo "Pushing version commit and tags to $HEAD_REF…"
          git push --follow-tags origin $HEAD_REF

          #? Create compressed archives of distribution files
          echo "Compressing dist directory…"
          tar -czf dist.tar.gz dist #? Create gzipped tar archive
          zip -r dist.zip dist #? Create zip archive

          #? Get the latest tag for reference
          LATEST_TAG=$(git describe --tags `git rev-list --tags --max-count=1`)
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      #* Step 8: Upload distribution archives as artifacts
      - name: Distribute
        if: steps.version_publish_compress.outputs.skipped_all != 'true' #? Only run if previous step didn't skip
        uses: actions/upload-artifact@v4
        with:
          name: distribution-archives #? Artifact name for download
          path: |
            dist.tar.gz
            dist.zip
          if-no-files-found: error #! Fail the step if no files are found to upload
